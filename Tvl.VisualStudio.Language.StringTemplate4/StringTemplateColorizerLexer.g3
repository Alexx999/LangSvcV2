lexer grammar StringTemplateColorizerLexer;

options {
    language=CSharp3;
    TokenLabelType=CommonToken;
}

@header
{
using Antlr4.StringTemplate.Compiler;
using Antlr4.StringTemplate.Misc;
}
@namespace{Tvl.VisualStudio.Language.StringTemplate4}

LPAREN : '(';
RPAREN : ')';
COMMA : ',';
DOT : '.';
COLON : ':';
DEFINED : '::=';
EQUALS : '=';
AT : '@';
LBRACK : '[';
RBRACK : ']';

ID	:	('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'-'|'_')*
	;

STRING
	:	'"'
		(	'\\' '"'
		|	'\\' ~'"'
		|	~('\\'|'"'|'\n')
		)*
		'"'
	;

BIGSTRING
	:	'<<'
		(	options {greedy=false;}
		:	'\\' '>'  // \> escape
		|	'\\' ~'>'
		|	~'\\'
		)*
        '>>'
	;

ANONYMOUS_TEMPLATE
    :	'{'
    	{
		IToken templateToken = new CommonToken(input, ANONYMOUS_TEMPLATE, 0, CharIndex, CharIndex);
		TemplateLexer lexer = new TemplateLexer(group.errMgr, input, templateToken, group.delimiterStartChar, group.delimiterStopChar);
		lexer.subtemplateDepth = 1;
		IToken t = lexer.NextToken();
		while ( lexer.subtemplateDepth>=1 || t.Type!=TemplateLexer.RCURLY )
		{
			if (t.Type == TemplateLexer.EOF_TYPE)
			{
				MismatchedTokenException e = new MismatchedTokenException('}', input);
				string msg = "missing final '}' in {...} anonymous template";
    			group.errMgr.GroupLexerError(ErrorType.SYNTAX_ERROR, SourceName, e, msg);
				break;
			}
			t = lexer.NextToken();
		}
		}
    	// don't match '}' here; our little {...} scanner loop matches it
    	// to terminate.
    ;

COMMENT
    :   '/*' .* '*/'
    ;

LINE_COMMENT
    :	'//' ~('\n'|'\r')*
    ;

WS
	:	(' '|'\t')*
	;

NEWLINE
	:	('\r'|'\n')* {Skip();}
	;

ANYCHAR
	:	.
	;
